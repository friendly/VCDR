Issues using the ca package
========================================================

```{r, echo=FALSE}
opts_knit$set(warning=FALSE, message=FALSE)
```
In VCDR, I'd like to try to explain correspondence analysis
visually as much as possible, both with well-constructed
plots of good data examples used elsewhere in the book
and with some conceptual diagrams for constructed data.

I would like to do this, as much as possible with the ca
package which, AFAICS provides the most general implementation
in R, in terms of computations.

In the SAS version of the book, this was all relatively 
easy because the CORRESP procedure carried out the
computations for all the cases (CA, MCA) and returned
output data sets in a convenient form for drawing customized
graphs.

However, I keep running into walls trying to do similar things
using the `ca` package.  Some of these are relatively easy
to fix, and I've already done some of them, using what is
now v. 0.56 that I've enhanced several times.

Done
----

* Because the `plot.` functions calculate the coordinates of the row/col points plotted, it  is necessary for the functions to return the coordinates plotted if one is to do further annotations, like drawing lines, adding additional text or symbols, etc.  Both
`plot.ca()` and `plot.mjca()` now return (invisibly) the coordinates plotted.

* For `plot.ca()`, options are provided for the colors of point labels as well as for point symbols.

* Both `plot.ca()` and `plot.mjca()` now have `xlab` and `ylab` arguments that default to `_auto_`, giving axis labels of
the form `Dimension 1 (78.12%)`.  In the case of `mjca()`, the percentages match those shown by `summary.mjca()`.

* Following the design of `MASS::corresp`, `ca` has been made a generic function, with S3 methods for other types of input.  
```{r}
library(ca)
methods("ca")
```

* The `summary.ca()` method has been modified in v. 0.56 to allow `rows=` and `columns=` arguments, defaulting to `TRUE`.
Using `FALSE` will allow an abbreviated output showing only the scree plot.


* `mjca` initially required a data.frame in _case form_, with all factor variables. It has been modified to also accept a table object,
which it expands internally.

TODO
----

### General:

* The output objects returned by `ca` and `mcja` should _all_ have
appropriate labels, particularly for matrices, using rownames and colnames.  I did this for the `rowcoord` and `colcoord` from ca(), but, for example, if I want to display the Burt matrix from `mjca`, the result is hard to understand w/o appropriate row/col labels.

* The `print` and `summary` methods seem designed to reproduce results from Michael's books or other software, and the code is all quite obtuse and inflexible.  For example, for a very basic summary display of a CA/MCA analysis, I favor just using the scree plot portion of the summary() method.  But in the book, I have to use a custom chunk hook to subset the output to only this.  I looked at the code for the print and summary methods and decided that it would have to be totally re-written to be
more flexible.  I suppose I could just add a `scree()` function to do what I want here.

More generally, there are no extractor functions for `ca` or `mjca`
objects as available for other statistical methods.  For example, following standard R conventions,
a `coef.ca()` method (or it could be called `coord.ca()`) could be used to extract the coordinates
from a ca object.  For example, here is a coef method I use in the `candisc` package:

```{r, eval=FALSE}
## coef method for a candisc object 
coef.candisc <- function( object, type=c("std", "raw", "structure"), ...) {
    type <- match.arg(type)
	  switch(type,
	  	std = object$coeffs.std,
	  	raw = object$coeffs.raw,
	  	structure = object$structure)
}
```
Doing this would allow moving some of the messy code outside the `ca` and `mjca` functions
as well. 


### mcja / plot.mjca


__Recommendation:__ Ideally, `mjca` should be able to handle input in
both table form and frequency form internally, by doing the steps shown above.  Rather than modifying
`mjca` internally, the R way is to make it generic, renaming the current version `mjca.default`
and provide S3 methods like `mjca.table`, `mjca.data.frame`, etc.

* The output structures from both `mjca` and `plot.mjca` limit my ability to make the kinds of plots I would like, for a variety of reasons, but the principal one is that the factor _names_ and the factor _level values_ are combined via `paste(factor, level, sep="")` into strings for plotting that are difficult to separate for even simple plot customization.

For example, I found it hard to change the default plot for mcja to
use only the level names, and distinguish the factors by color.
The following code does what I want for one plot, but it too ugly
to include in the text, no less try to explain to a reader why it
is necessary, or how to do it with his/her data.

```{r, tidy=FALSE}
# plot, but don't use point labels
res <- plot(haireye.mca, labels=0)

coords <- res$cols
# simplify point labels, for display purposes
rownames(coords) <- gsub("Hair|Eye", "", rownames(coords))
text(coords, rownames(coords), col=rep(c("blue", "red"), each=4), pos=3)

coords[1:4,] <- coords[order(coords[1:4,1]),] 
coords[5:8,] <- coords[4+order(coords[5:8,1]),]
lines(coords[1:4,], lty=1, col="blue")
lines(coords[5:8,], lty=4, col="red")
```
You may not like the use of lines connecting categories in MCA plots (as I do), but this is really
just an argument for "let them do it, if they want to".

For the 3-way table, this is even harder:
```{r}
# 3-way table
HEC.df <- expand.dft(as.data.frame(HairEyeColor))
HEC.mca <- mjca(HEC.df)
summary(HEC.mca)

res3 <- plot(HEC.mca)
res3
```

__Recommendation:__ Minimally, `mjca` should construct the names for factor-level combinations in the form `paste(factor, level, sep=sep)` where `sep` is an input argument like `"."` or `":"` by default. The value `sep=""` would give the present behavior.

`MASS::corresp` also provides an argument `abbrev`, where `abbrev=TRUE` means that the names are abbreviated to just the level value, which will suffice if the level values are all distinct.

More generally, this would all be much easier if the output object(s) from `mjca` were re-designed
so that the factor and level values appeared in separate columns of a __data frame__.  Using my example above, this would look something like the following:
```{r}
coords2 <- as.data.frame(res$cols)
coords2$factor <- rep(c("Hair", "Eye"), each=4)
coords2$level <- gsub("Hair|Eye", "", rownames(coords2))
coords2
```


