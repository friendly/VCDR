\subsection{Vectors}
\ixon{vector}
The simplest data structure in \R is a \term{vector}, a one-dimensional
collection of elements of the same type. An easy way to create a vector is with
the \func{c} function, which combines its arguments.  The following examples create
and print vectors of length 4, containing numbers, character strings, and
logical values, respectively:

<<vec1>>=
c(17, 20, 15, 40)
c("female", "male", "female", "male")
c(TRUE, TRUE, FALSE, FALSE)
@

To store these values in variables, \R uses the assignment operator (\code{<-})
or equals sign (\code{=}). This creates a variable named on the left-hand side.
An assignment doesn't print the result, but a bare expression does, so you can
assign and print by surrounding the assignment with \code{()}. 
\ix{assignment operator}

<<vec2>>=
count <- c(17, 20, 15, 40)                       # assign
count                                            # print
(sex <- c("female", "male", "female", "male"))   # both
(passed <- c(TRUE, TRUE, FALSE, FALSE))
@

Other useful functions for creating vectors are: 
\ix{:|textttt}
\begin{itemize*}
  \item The \code{:} operator for generating consecutive integer sequences, e.g.,
  \code{1:10} gives the integers 1 to 10.  The \func{seq} function is more general, taking the forms
\code{seq(from, to)},
\code{seq(from, to, by= )}, and
\code{seq(from, to, length.out= )} where the optional argument \code{by} specifies the interval between adjacent values and \code{length.out} gives the desired length of the
result.

  \item The \func{rep} function generates repeated sequences, replicating
  its first argument (which may be a vector) a given number of \code{times},
  and individual elements can be repeated with \code{each} until an
  optional \code{length.out} is obtained.
\end{itemize*}

<<seq-rep>>=
seq(10, 100, by = 10)          # give interval
seq(0, 1, length.out = 11)     # give length
(sex <- rep(c("female", "male"), times = 2))
(sex <- rep(c("female", "male"), length.out = 4))  # same
(passed <- rep(c(TRUE, FALSE), each = 2))
 @

\ixoff{vector}

\subsection{Matrices}
\ixon{matrices}
A \textbf{matrix} is a two-dimensional array of elements of the same type composed
in a rectangular array of rows and columns. Matrices can be created by the function
\code{matrix(values, nrow, ncol)}, which reshapes the elements in
the first argument (\code{values}) to a matrix with \code{nrow} rows and
\code{ncol} columns. By default, the elements are filled in columnwise, unless
the optional argument \code{byrow = TRUE} is given.

<<mat1>>=
(matA <- matrix(1:8, nrow = 2, ncol = 4))
(matB <- matrix(1:8, nrow = 2, ncol = 4, byrow = TRUE))
(matC <- matrix(1:4, nrow = 2, ncol = 4))
@
\noindent The last example illustrates that the values in the first argument are recycled
as necessary to fill the given number of rows and columns.

All matrices have a dimensions attribute, a vector of length two giving the number
of rows and columns, retrieved with the function \func{dim}. Labels for the rows and
columns can be assigned using \func{dimnames},%
\footnote{
The \code{dimnames} can also be specified as an optional argument to \func{matrix}.
}
which takes a list of two vectors for the
row names and column names, respectively. To see the structure of a matrix
(or any other \R object) and its attributes, you can
use the \func{str} function, as shown in the example below.

<<mat2>>=
dim(matA)
str(matA)
dimnames(matA) <- list(c("M", "F"), LETTERS[1:4])
matA
str(matA)
@
Additionally, names for the row and column \emph{variables} themselves can also be assigned in the
\code{dimnames} call by giving each dimension vector a name.
<<mat3>>=
dimnames(matA) <- list(sex = c("M", "F"), group = LETTERS[1:4])
## or: names(dimnames(matA)) <- c("Sex", "Group")
matA
str(matA)
@
\noindent (\code{LETTERS} is a predefined character
vector of the 26 uppercase letters).
Matrices can also be created or enlarged by ``binding'' vectors or matrices together 
\ix{vector!binding} 
\ix{matrix!binding}
by rows or columns:
\begin{itemize*}
  \item \code{rbind(a, b, c)} creates a matrix with the vectors \code{a}, \code{b}, and \code{c} as its rows, recycling the elements as necessary to the length of the longest one.
  \item \code{cbind(a, b, c)} creates a matrix with the vectors \code{a}, \code{b}, and \code{c} as its columns.
  \item \code{rbind(mat, a, b, ...)} and \code{cbind(mat, a, b, ...)} add additional
  rows (columns) to a matrix \code{mat}, recycling or subsetting the elements in the
  vectors to conform with the size of the matrix.
\end{itemize*}

<<mat4>>=
rbind(matA, c(10, 20))
cbind(matA, c(10, 20))
@

\noindent Rows and columns can be swapped (transposed)
using \func{t}: 
\ix{vector!transposing}
\ix{matrix!transposing}

<<mat5>>=
t(matA)
@

\noindent Finally, we note that basic computations involving matrices
are performed \emph{element-wise}:

<<mat6>>=
2 * matA / 100
@

\noindent Special operators and functions do exist for matrix
operations, such as \code{\%*\%} for the matrix product. %
\ixoff{matrices}

\subsection{Arrays}
\ixon{arrays}
Higher-dimensional arrays are less frequently encountered in traditional data analysis,
but they are of great use for categorical data, where frequency tables of three or more
variables can be naturally represented as arrays, with one dimension for each
table variable.

The function \code{array(values, dim)} takes the elements in \code{values} and
reshapes these into an array whose dimensions are given in the vector \code{dim}.
The number of dimensions is the length of \code{dim}.  As with matrices, the
elements are filled in with the first dimension (rows) varying most rapidly,
then by the second dimension (columns) and so on for all further dimensions,
which can be considered as layers.
A matrix is just the special case of an array with two dimensions.

<<array1>>=
dims <-  c(2, 4, 2)
(arrayA <- array(1:16, dim = dims))      # 2 rows, 4 columns, 2 layers
str(arrayA)
(arrayB <- array(1:16, dim = c(2, 8)))   # 2 rows, 8 columns
str(arrayB)
@
In the same way that we can assign labels to the rows and columns 
in matrices, we can assign these attributes to \code{dimnames(arrayA)}, or
include this information in a \code{dimnames=} argument to \func{array}.

<<array2>>=
dimnames(arrayA) <- list(sex = c("M", "F"),
                         group = letters[1:4],
                         time = c("Pre", "Post"))
arrayA
str(arrayA)
@

Arrays in \R can contain any single type of elements--- numbers,
character strings, logicals.  \R also has a variety of functions
(e.g., \func{table}, \func{xtabs})
for creating and manipulating \class{table} objects, which are
specialized forms of matrices and arrays containing integer
frequencies in a contingency table. These are discussed in more
detail below (\secref{sec:table}).

\ixoff{arrays}